<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>å…­è¾¹å½¢è‡ªç”±æ¢ç´¢åœ°å›¾æµ‹è¯•å™¨ v4</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Arial', sans-serif;
      background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
      color: #f0f0f0;
      padding: 20px;
    }
    
    .container {
      max-width: 1600px;
      margin: 0 auto;
    }
    
    h1 {
      text-align: center;
      color: #C8AA6E;
      font-size: 2.5rem;
      margin-bottom: 10px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
    }
    
    .subtitle {
      text-align: center;
      color: #8899aa;
      margin-bottom: 30px;
      font-size: 1.1rem;
    }
    
    .controls {
      display: flex;
      gap: 15px;
      justify-content: center;
      margin-bottom: 30px;
      flex-wrap: wrap;
    }
    
    button {
      background: linear-gradient(135deg, #C8AA6E 0%, #9d844a 100%);
      color: #0a0e27;
      border: none;
      padding: 12px 24px;
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      border-radius: 8px;
      box-shadow: 0 4px 6px rgba(0,0,0,0.3);
      transition: all 0.3s;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 12px rgba(200, 170, 110, 0.4);
    }
    
    button:active {
      transform: translateY(0);
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 30px;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 12px;
      border: 2px solid rgba(200, 170, 110, 0.3);
    }
    
    .stat-item {
      background: rgba(255,255,255,0.05);
      padding: 15px;
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .stat-label {
      color: #8899aa;
      font-size: 0.9rem;
      margin-bottom: 5px;
    }
    
    .stat-value {
      color: #C8AA6E;
      font-size: 1.8rem;
      font-weight: bold;
    }
    
    .stat-value.success {
      color: #4ade80;
    }
    
    .stat-value.error {
      color: #ef4444;
    }
    
    #canvas-container {
      background: rgba(0,0,0,0.5);
      border-radius: 12px;
      padding: 20px;
      border: 2px solid rgba(200, 170, 110, 0.3);
      overflow: auto;
      max-height: 800px;
    }
    
    #map-canvas {
      display: block;
      margin: 0 auto;
      cursor: grab;
    }
    
    #map-canvas:active {
      cursor: grabbing;
    }
    
    .legend {
      display: flex;
      gap: 20px;
      justify-content: center;
      margin-top: 20px;
      flex-wrap: wrap;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 8px 16px;
      background: rgba(255,255,255,0.05);
      border-radius: 6px;
    }
    
    .legend-color {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 2px solid rgba(255,255,255,0.3);
    }
    
    .test-section {
      margin-top: 30px;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 12px;
      border: 2px solid rgba(200, 170, 110, 0.3);
    }
    
    .test-section h2 {
      color: #C8AA6E;
      margin-bottom: 15px;
    }
    
    #test-results {
      display: grid;
      gap: 10px;
    }
    
    .test-result {
      padding: 12px;
      border-radius: 6px;
      background: rgba(255,255,255,0.05);
      border-left: 4px solid;
    }
    
    .test-result.success {
      border-color: #4ade80;
    }
    
    .test-result.error {
      border-color: #ef4444;
    }
    
    .exploration-panel {
      margin-top: 30px;
      padding: 20px;
      background: rgba(0,0,0,0.3);
      border-radius: 12px;
      border: 2px solid rgba(200, 170, 110, 0.3);
    }
    
    .exploration-panel h2 {
      color: #C8AA6E;
      margin-bottom: 15px;
    }
    
    .exploration-controls {
      display: flex;
      gap: 10px;
      margin-top: 15px;
    }
    
    .step-info {
      padding: 10px;
      background: rgba(255,255,255,0.05);
      border-radius: 6px;
      margin-top: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>â¬¡ å…­è¾¹å½¢è‡ªç”±æ¢ç´¢åœ°å›¾æµ‹è¯•å™¨ v4</h1>
    <p class="subtitle">çœŸæ­£çš„å…­è¾¹å½¢ç½‘æ ¼è‡ªç”±æ¢ç´¢ - æ— DAGé™åˆ¶ï¼Œæˆ˜äº‰è¿·é›¾ï¼ŒBOSSä¿è¯å¯è¾¾</p>
    
    <div class="controls">
      <button onclick="generateMap(1)">ğŸ® ç”Ÿæˆ ACT1 åœ°å›¾</button>
      <button onclick="generateMap(2)">âš”ï¸ ç”Ÿæˆ ACT2 åœ°å›¾</button>
      <button onclick="generateMap(3)">ğŸ”¥ ç”Ÿæˆ ACT3 åœ°å›¾</button>
      <button onclick="runBatchTest(1, 100)">ğŸ“Š æ‰¹é‡æµ‹è¯• ACT1 (100æ¬¡)</button>
      <button onclick="runBatchTest(2, 100)">ğŸ“Š æ‰¹é‡æµ‹è¯• ACT2 (100æ¬¡)</button>
      <button onclick="runBatchTest(3, 100)">ğŸ“Š æ‰¹é‡æµ‹è¯• ACT3 (100æ¬¡)</button>
      <button onclick="resetExploration()">ğŸ”„ é‡ç½®æ¢ç´¢</button>
    </div>
    
    <div class="stats">
      <div class="stat-item">
        <div class="stat-label">æ€»èŠ‚ç‚¹æ•°</div>
        <div class="stat-value" id="stat-nodes">-</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">åœ°å›¾å°ºå¯¸</div>
        <div class="stat-value" id="stat-size">-</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">èŠ‚ç‚¹å¯†åº¦</div>
        <div class="stat-value" id="stat-density">-</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">BOSSå¯è¾¾</div>
        <div class="stat-value" id="stat-reachable">-</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">å·²æ¢ç´¢èŠ‚ç‚¹</div>
        <div class="stat-value" id="stat-explored">0</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">å½“å‰å¯é€‰</div>
        <div class="stat-value" id="stat-available">0</div>
      </div>
    </div>
    
    <div id="canvas-container">
      <canvas id="map-canvas"></canvas>
    </div>
    
    <div class="legend">
      <div class="legend-item">
        <div class="legend-color" style="background: #4ade80;"></div>
        <span>èµ·ç‚¹ (START)</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #ef4444;"></div>
        <span>BOSS</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #dc2626;"></div>
        <span>æˆ˜æ–— (BATTLE)</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #f59e0b;"></div>
        <span>å•†åº— (SHOP)</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #3b82f6;"></div>
        <span>äº‹ä»¶ (EVENT)</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #10b981;"></div>
        <span>ä¼‘æ¯ (REST)</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #8b5cf6;"></div>
        <span>å®ç®± (CHEST)</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: rgba(255,255,255,0.1); border: 2px solid #C8AA6E;"></div>
        <span>å·²æ¢ç´¢</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: rgba(255,255,255,0.3);"></div>
        <span>å¯æ¢ç´¢</span>
      </div>
    </div>
    
    <div class="exploration-panel">
      <h2>ğŸ§­ æ¨¡æ‹Ÿæ¢ç´¢</h2>
      <p style="color: #8899aa; margin-bottom: 10px;">
        ç‚¹å‡»åœ°å›¾ä¸Šçš„å…­è¾¹å½¢èŠ‚ç‚¹æ¥æ¨¡æ‹Ÿç©å®¶æ¢ç´¢ã€‚åªèƒ½é€‰æ‹©ç›¸é‚»çš„æœªæ¢ç´¢èŠ‚ç‚¹ã€‚
      </p>
      <div class="exploration-controls">
        <button onclick="autoExplore()">ğŸ¤– è‡ªåŠ¨æ¢ç´¢åˆ°BOSS</button>
        <button onclick="resetExploration()">ğŸ”„ é‡ç½®æ¢ç´¢</button>
      </div>
      <div class="step-info" id="step-info">
        ç­‰å¾…å¼€å§‹æ¢ç´¢...
      </div>
    </div>
    
    <div class="test-section">
      <h2>ğŸ“Š æ‰¹é‡æµ‹è¯•ç»“æœ</h2>
      <div id="test-results"></div>
    </div>
  </div>

  <script type="module">
    import { generateGridMap } from './src/data/gridMapLayout_v4.js';
    import { getHexNeighbors, offsetToPixel } from './src/utils/hexagonGrid.js';
    
    // å…¨å±€å˜é‡
    let currentMapData = null;
    let exploredNodes = new Set();
    let currentNode = null;
    
    const canvas = document.getElementById('map-canvas');
    const ctx = canvas.getContext('2d');
    
    const HEX_SIZE = 30;
    const PADDING = 80;
    let nodePositionMap = new Map();
    let bounds = { minX: 0, maxX: 0, minY: 0, maxY: 0 };
    
    // ===========================
    // ç”Ÿæˆåœ°å›¾
    // ===========================
    window.generateMap = (act) => {
      try {
        currentMapData = generateGridMap(act, []);
        exploredNodes = new Set();
        currentNode = currentMapData.startNode;
        exploredNodes.add(`${currentNode.row}-${currentNode.col}`);
        
        updateStats();
        renderMap();
        updateExplorationInfo();
      } catch (error) {
        console.error('åœ°å›¾ç”Ÿæˆå¤±è´¥:', error);
        alert('åœ°å›¾ç”Ÿæˆå¤±è´¥: ' + error.message);
      }
    };
    
    // ===========================
    // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
    // ===========================
    function updateStats() {
      if (!currentMapData) return;
      
      const { nodes, grid, totalFloors } = currentMapData;
      const GRID_COLS = 11;
      const totalCells = totalFloors * GRID_COLS;
      const density = ((nodes.length / totalCells) * 100).toFixed(1);
      
      // BFSæ£€æŸ¥å¯è¾¾æ€§
      const reachable = checkBossReachable();
      
      document.getElementById('stat-nodes').textContent = nodes.length;
      document.getElementById('stat-size').textContent = `${totalFloors}Ã—${GRID_COLS}`;
      document.getElementById('stat-density').textContent = `${density}%`;
      
      const reachableEl = document.getElementById('stat-reachable');
      reachableEl.textContent = reachable ? 'âœ… æ˜¯' : 'âŒ å¦';
      reachableEl.className = 'stat-value ' + (reachable ? 'success' : 'error');
      
      document.getElementById('stat-explored').textContent = exploredNodes.size;
      
      // è®¡ç®—å¯é€‰èŠ‚ç‚¹
      const available = getAvailableNodes();
      document.getElementById('stat-available').textContent = available.length;
    }
    
    // ===========================
    // BFSæ£€æŸ¥BOSSå¯è¾¾æ€§
    // ===========================
    function checkBossReachable() {
      if (!currentMapData) return false;
      
      const { grid, startNode, bossNode, totalFloors } = currentMapData;
      const GRID_COLS = 11;
      const visited = new Set();
      const queue = [startNode];
      visited.add(`${startNode.row}-${startNode.col}`);
      
      while (queue.length > 0) {
        const current = queue.shift();
        
        if (current.row === bossNode.row && current.col === bossNode.col) {
          return true;
        }
        
        const neighbors = getHexNeighbors(current.row, current.col, totalFloors, GRID_COLS);
        for (const [r, c] of neighbors) {
          const neighbor = grid[r][c];
          if (neighbor && !visited.has(`${r}-${c}`)) {
            visited.add(`${r}-${c}`);
            queue.push(neighbor);
          }
        }
      }
      
      return false;
    }
    
    // ===========================
    // è·å–å¯æ¢ç´¢çš„èŠ‚ç‚¹
    // ===========================
    function getAvailableNodes() {
      if (!currentMapData || !currentNode) return [];
      
      const { grid, totalFloors } = currentMapData;
      const GRID_COLS = 11;
      const neighbors = getHexNeighbors(currentNode.row, currentNode.col, totalFloors, GRID_COLS);
      const available = [];
      
      for (const [r, c] of neighbors) {
        const neighbor = grid[r][c];
        if (neighbor && !exploredNodes.has(`${r}-${c}`)) {
          available.push(neighbor);
        }
      }
      
      return available;
    }
    
    // ===========================
    // æ¸²æŸ“åœ°å›¾
    // ===========================
    function renderMap() {
      if (!currentMapData) return;
      
      const { grid, totalFloors, startNode, bossNode } = currentMapData;
      const GRID_COLS = 11;
      
      nodePositionMap = new Map();
      bounds = currentMapData.nodes.reduce((acc, node) => {
        const pos = offsetToPixel(node.row, node.col, HEX_SIZE);
        nodePositionMap.set(`${node.row}-${node.col}`, pos);
        acc.minX = Math.min(acc.minX, pos.x);
        acc.maxX = Math.max(acc.maxX, pos.x);
        acc.minY = Math.min(acc.minY, pos.y);
        acc.maxY = Math.max(acc.maxY, pos.y);
        return acc;
      }, { minX: Infinity, maxX: -Infinity, minY: Infinity, maxY: -Infinity });
      
      const width = (bounds.maxX - bounds.minX) + PADDING * 2 + HEX_SIZE * 2;
      const height = (bounds.maxY - bounds.minY) + PADDING * 2 + HEX_SIZE * 2;
      canvas.width = width;
      canvas.height = height;
      
      // æ¸…ç©ºç”»å¸ƒ
      ctx.fillStyle = '#0a0e27';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // è·å–å¯é€‰èŠ‚ç‚¹
      const availableNodes = getAvailableNodes();
      const availableSet = new Set(availableNodes.map(n => `${n.row}-${n.col}`));
      
      // ç»˜åˆ¶è¿æ¥çº¿ï¼ˆåªæ˜¾ç¤ºå·²æ¢ç´¢èŠ‚ç‚¹ä¹‹é—´çš„è¿æ¥ï¼‰
      ctx.strokeStyle = 'rgba(200, 170, 110, 0.3)';
      ctx.lineWidth = 2;
      for (const node of currentMapData.nodes) {
        if (!exploredNodes.has(`${node.row}-${node.col}`)) continue;
        
        const nodePos = nodePositionMap.get(`${node.row}-${node.col}`);
        const neighbors = getHexNeighbors(node.row, node.col, totalFloors, GRID_COLS);
        
        for (const [r, c] of neighbors) {
          const neighbor = grid[r][c];
          if (neighbor && exploredNodes.has(`${r}-${c}`)) {
            const neighborPos = nodePositionMap.get(`${r}-${c}`);
            ctx.beginPath();
            ctx.moveTo(nodePos.x - bounds.minX + PADDING, nodePos.y - bounds.minY + PADDING);
            ctx.lineTo(neighborPos.x - bounds.minX + PADDING, neighborPos.y - bounds.minY + PADDING);
            ctx.stroke();
          }
        }
      }
      
      // ç»˜åˆ¶èŠ‚ç‚¹
      for (const node of currentMapData.nodes) {
        const pos = nodePositionMap.get(`${node.row}-${node.col}`);
        if (!pos) continue;
        const x = pos.x - bounds.minX + PADDING;
        const y = pos.y - bounds.minY + PADDING;
        
        const isExplored = exploredNodes.has(`${node.row}-${node.col}`);
        const isAvailable = availableSet.has(`${node.row}-${node.col}`);
        const isCurrent = currentNode && node.row === currentNode.row && node.col === currentNode.col;
        
        // ç»˜åˆ¶å…­è¾¹å½¢
        drawHexagon(x, y, HEX_SIZE * 0.8, node, isExplored, isAvailable, isCurrent);
      }
    }
    
    // ===========================
    // ç»˜åˆ¶å…­è¾¹å½¢
    // ===========================
    function drawHexagon(x, y, size, node, isExplored, isAvailable, isCurrent) {
      const { startNode, bossNode } = currentMapData;
      
      // ç¡®å®šé¢œè‰²
      let fillColor;
      if (node.row === startNode.row && node.col === startNode.col) {
        fillColor = '#4ade80'; // èµ·ç‚¹
      } else if (node.row === bossNode.row && node.col === bossNode.col) {
        fillColor = '#ef4444'; // BOSS
      } else {
        switch (node.type) {
          case 'BATTLE': fillColor = '#dc2626'; break;
          case 'SHOP': fillColor = '#f59e0b'; break;
          case 'EVENT': fillColor = '#3b82f6'; break;
          case 'REST': fillColor = '#10b981'; break;
          case 'CHEST': fillColor = '#8b5cf6'; break;
          default: fillColor = '#6b7280';
        }
      }
      
      // ç»˜åˆ¶å…­è¾¹å½¢è·¯å¾„
      ctx.beginPath();
      for (let i = 0; i < 6; i++) {
        const angle = Math.PI / 3 * i;
        const hx = x + size * Math.cos(angle);
        const hy = y + size * Math.sin(angle);
        if (i === 0) ctx.moveTo(hx, hy);
        else ctx.lineTo(hx, hy);
      }
      ctx.closePath();
      
      // å¡«å……
      if (isExplored) {
        ctx.fillStyle = 'rgba(255,255,255,0.1)';
        ctx.fill();
        ctx.strokeStyle = '#C8AA6E';
        ctx.lineWidth = 2;
        ctx.stroke();
      } else if (isAvailable) {
        ctx.fillStyle = fillColor;
        ctx.globalAlpha = 0.8;
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.strokeStyle = '#C8AA6E';
        ctx.lineWidth = 3;
        ctx.stroke();
      } else {
        ctx.fillStyle = fillColor;
        ctx.globalAlpha = 0.3;
        ctx.fill();
        ctx.globalAlpha = 1;
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 1;
        ctx.stroke();
      }
      
      // å½“å‰èŠ‚ç‚¹é«˜äº®
      if (isCurrent) {
        ctx.strokeStyle = '#fff';
        ctx.lineWidth = 4;
        ctx.stroke();
      }
    }
    
    // ===========================
    // ç”»å¸ƒç‚¹å‡»äº‹ä»¶
    // ===========================
    canvas.addEventListener('click', (e) => {
      if (!currentMapData) return;
      
      const rect = canvas.getBoundingClientRect();
      const clickX = e.clientX - rect.left;
      const clickY = e.clientY - rect.top;
      
      const availableNodes = getAvailableNodes();
      
      for (const node of availableNodes) {
        const pos = nodePositionMap.get(`${node.row}-${node.col}`);
        if (!pos) continue;
        const x = pos.x - bounds.minX + PADDING;
        const y = pos.y - bounds.minY + PADDING;
        
        const dx = clickX - x;
        const dy = clickY - y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance < HEX_SIZE * 0.8) {
          exploreNode(node);
          return;
        }
      }
    });
    
    // ===========================
    // æ¢ç´¢èŠ‚ç‚¹
    // ===========================
    function exploreNode(node) {
      exploredNodes.add(`${node.row}-${node.col}`);
      currentNode = node;
      updateStats();
      renderMap();
      updateExplorationInfo();
      
      // æ£€æŸ¥æ˜¯å¦åˆ°è¾¾BOSS
      if (node.row === currentMapData.bossNode.row && node.col === currentMapData.bossNode.col) {
        setTimeout(() => {
          alert(`ğŸ‰ åˆ°è¾¾BOSSï¼æ€»å…±æ¢ç´¢äº† ${exploredNodes.size} ä¸ªèŠ‚ç‚¹ã€‚`);
        }, 100);
      }
    }
    
    // ===========================
    // æ›´æ–°æ¢ç´¢ä¿¡æ¯
    // ===========================
    function updateExplorationInfo() {
      const info = document.getElementById('step-info');
      if (!currentNode) {
        info.textContent = 'ç­‰å¾…å¼€å§‹æ¢ç´¢...';
        return;
      }
      
      const available = getAvailableNodes();
      const isBoss = currentNode.row === currentMapData.bossNode.row && currentNode.col === currentMapData.bossNode.col;
      
      if (isBoss) {
        info.innerHTML = `
          <div style="color: #4ade80; font-weight: bold; font-size: 1.2rem;">
            ğŸ‰ å·²åˆ°è¾¾BOSSï¼æ€»å…±æ¢ç´¢äº† ${exploredNodes.size} ä¸ªèŠ‚ç‚¹ã€‚
          </div>
        `;
      } else {
        info.innerHTML = `
          <div><strong>å½“å‰ä½ç½®:</strong> Row ${currentNode.row}, Col ${currentNode.col} (${currentNode.type})</div>
          <div><strong>å¯é€‰æ–¹å‘:</strong> ${available.length} ä¸ª</div>
          <div style="margin-top: 5px; color: #8899aa;">
            ${available.map(n => `Row ${n.row}, Col ${n.col} (${n.type})`).join(' | ')}
          </div>
        `;
      }
    }
    
    // ===========================
    // è‡ªåŠ¨æ¢ç´¢
    // ===========================
    window.autoExplore = () => {
      if (!currentMapData || !currentNode) return;
      
      const interval = setInterval(() => {
        const available = getAvailableNodes();
        
        if (available.length === 0) {
          clearInterval(interval);
          alert('æ— æ³•ç»§ç»­æ¢ç´¢ï¼');
          return;
        }
        
        // é€‰æ‹©æœ€æ¥è¿‘BOSSçš„èŠ‚ç‚¹
        const bossNode = currentMapData.bossNode;
        let bestNode = available[0];
        let minDist = Infinity;
        
        for (const node of available) {
          const dist = Math.abs(node.row - bossNode.row) + Math.abs(node.col - bossNode.col);
          if (dist < minDist) {
            minDist = dist;
            bestNode = node;
          }
        }
        
        exploreNode(bestNode);
        
        // åˆ°è¾¾BOSS
        if (bestNode.row === bossNode.row && bestNode.col === bossNode.col) {
          clearInterval(interval);
        }
      }, 300);
    };
    
    // ===========================
    // é‡ç½®æ¢ç´¢
    // ===========================
    window.resetExploration = () => {
      if (!currentMapData) return;
      exploredNodes = new Set();
      currentNode = currentMapData.startNode;
      exploredNodes.add(`${currentNode.row}-${currentNode.col}`);
      updateStats();
      renderMap();
      updateExplorationInfo();
    };
    
    // ===========================
    // æ‰¹é‡æµ‹è¯•
    // ===========================
    window.runBatchTest = (act, count) => {
      const results = [];
      let successCount = 0;
      
      for (let i = 0; i < count; i++) {
        try {
          const mapData = generateGridMap(act, []);
          const reachable = checkBossReachableForMap(mapData);
          
          if (reachable) successCount++;
          
          results.push({
            id: i + 1,
            nodes: mapData.nodes.length,
            rows: mapData.totalFloors,
            reachable
          });
        } catch (error) {
          results.push({
            id: i + 1,
            error: error.message
          });
        }
      }
      
      displayTestResults(act, results, successCount, count);
    };
    
    function checkBossReachableForMap(mapData) {
      const { grid, startNode, bossNode, totalFloors } = mapData;
      const GRID_COLS = 11;
      const visited = new Set();
      const queue = [startNode];
      visited.add(`${startNode.row}-${startNode.col}`);
      
      while (queue.length > 0) {
        const current = queue.shift();
        
        if (current.row === bossNode.row && current.col === bossNode.col) {
          return true;
        }
        
        const neighbors = getHexNeighbors(current.row, current.col, totalFloors, GRID_COLS);
        for (const [r, c] of neighbors) {
          const neighbor = grid[r][c];
          if (neighbor && !visited.has(`${r}-${c}`)) {
            visited.add(`${r}-${c}`);
            queue.push(neighbor);
          }
        }
      }
      
      return false;
    }
    
    function displayTestResults(act, results, successCount, total) {
      const container = document.getElementById('test-results');
      const successRate = ((successCount / total) * 100).toFixed(1);
      
      const avgNodes = results.reduce((sum, r) => sum + (r.nodes || 0), 0) / total;
      const avgRows = results.reduce((sum, r) => sum + (r.rows || 0), 0) / total;
      
      container.innerHTML = `
        <div class="test-result ${successRate >= 90 ? 'success' : 'error'}">
          <strong>ACT${act} æ‰¹é‡æµ‹è¯• (${total}æ¬¡)</strong><br>
          æˆåŠŸç‡: ${successRate}% (${successCount}/${total})<br>
          å¹³å‡èŠ‚ç‚¹æ•°: ${avgNodes.toFixed(1)}<br>
          å¹³å‡è¡Œæ•°: ${avgRows.toFixed(1)}
        </div>
      `;
    }
    
    // åˆå§‹åŒ–
    console.log('å…­è¾¹å½¢è‡ªç”±æ¢ç´¢åœ°å›¾æµ‹è¯•å™¨å·²åŠ è½½');
  </script>
</body>
</html>


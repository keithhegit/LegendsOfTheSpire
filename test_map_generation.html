<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>åœ°å›¾ç”Ÿæˆæµ‹è¯• - Legends of the Spire</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #0a0e27;
      color: #c9aa71;
      padding: 20px;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
    }
    
    h1 {
      text-align: center;
      margin-bottom: 20px;
      color: #f0e6d2;
      text-shadow: 0 0 10px rgba(200, 170, 110, 0.5);
    }
    
    .controls {
      background: #1e2328;
      padding: 20px;
      border-radius: 10px;
      margin-bottom: 20px;
      border: 2px solid #785a28;
    }
    
    .controls button {
      background: linear-gradient(to bottom, #c8aa6e, #785a28);
      color: #0a0e27;
      border: none;
      padding: 10px 20px;
      margin: 5px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      font-size: 14px;
      transition: all 0.3s;
    }
    
    .controls button:hover {
      transform: scale(1.05);
      box-shadow: 0 0 15px rgba(200, 170, 110, 0.7);
    }
    
    .controls button:active {
      transform: scale(0.95);
    }
    
    .stats {
      background: #1e2328;
      padding: 15px;
      border-radius: 10px;
      margin-bottom: 20px;
      border: 2px solid #785a28;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
    }
    
    .stat-item {
      text-align: center;
    }
    
    .stat-label {
      font-size: 12px;
      color: #a09b8c;
      margin-bottom: 5px;
    }
    
    .stat-value {
      font-size: 24px;
      font-weight: bold;
      color: #f0e6d2;
    }
    
    .stat-value.success {
      color: #00ff00;
    }
    
    .stat-value.warning {
      color: #ff9900;
    }
    
    .stat-value.error {
      color: #ff0000;
    }
    
    #mapCanvas {
      background: #0a0e27;
      border: 3px solid #785a28;
      border-radius: 10px;
      box-shadow: 0 0 30px rgba(200, 170, 110, 0.3);
      display: block;
      margin: 0 auto;
    }
    
    .legend {
      background: #1e2328;
      padding: 15px;
      border-radius: 10px;
      margin-top: 20px;
      border: 2px solid #785a28;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 15px;
    }
    
    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .legend-color {
      width: 30px;
      height: 30px;
      border-radius: 50%;
      border: 2px solid #c9aa71;
    }
    
    .log-container {
      background: #1e2328;
      padding: 15px;
      border-radius: 10px;
      margin-top: 20px;
      border: 2px solid #785a28;
      max-height: 300px;
      overflow-y: auto;
    }
    
    .log-container pre {
      font-size: 12px;
      color: #a09b8c;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ—ºï¸ å…­è¾¹å½¢åœ°å›¾ç”Ÿæˆæµ‹è¯•</h1>
    
    <div class="controls">
      <button onclick="generateMap(1)">ç”Ÿæˆ ACT1 åœ°å›¾ (10å±‚)</button>
      <button onclick="generateMap(2)">ç”Ÿæˆ ACT2 åœ°å›¾ (20å±‚)</button>
      <button onclick="generateMap(3)">ç”Ÿæˆ ACT3 åœ°å›¾ (30å±‚)</button>
      <button onclick="runBatchTest()">æ‰¹é‡æµ‹è¯• (100æ¬¡)</button>
      <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
    </div>
    
    <div class="stats">
      <div class="stat-item">
        <div class="stat-label">å½“å‰ACT</div>
        <div class="stat-value" id="currentAct">-</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">æ€»èŠ‚ç‚¹æ•°</div>
        <div class="stat-value" id="totalNodes">-</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">æœ€çŸ­è·¯å¾„</div>
        <div class="stat-value" id="minSteps">-</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">æœ€é•¿è·¯å¾„</div>
        <div class="stat-value" id="maxSteps">-</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">BOSSå¯è¾¾</div>
        <div class="stat-value" id="reachable">-</div>
      </div>
      <div class="stat-item">
        <div class="stat-label">ç”Ÿæˆè€—æ—¶</div>
        <div class="stat-value" id="generateTime">-</div>
      </div>
    </div>
    
    <canvas id="mapCanvas" width="1200" height="800"></canvas>
    
    <div class="legend">
      <div class="legend-item">
        <div class="legend-color" style="background: #00ff00;"></div>
        <span>èµ·ç‚¹ (START)</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #ff0000;"></div>
        <span>BOSS</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #ff6600;"></div>
        <span>æˆ˜æ–— (BATTLE)</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #00ccff;"></div>
        <span>å•†åº— (SHOP)</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #ffff00;"></div>
        <span>äº‹ä»¶ (EVENT)</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #00ff99;"></div>
        <span>ä¼‘æ¯ (REST)</span>
      </div>
      <div class="legend-item">
        <div class="legend-color" style="background: #ff00ff;"></div>
        <span>å®ç®± (CHEST)</span>
      </div>
    </div>
    
    <div class="log-container">
      <pre id="logOutput">ç‚¹å‡»æŒ‰é’®å¼€å§‹ç”Ÿæˆåœ°å›¾...</pre>
    </div>
  </div>
  
  <script type="module">
    import { generateGridMap } from './src/data/gridMapLayout_v3.js';
    import { generateHexagonPath, offsetToPixel } from './src/utils/hexagonGrid.js';
    
    let currentMapData = null;
    
    // èŠ‚ç‚¹ç±»å‹é¢œè‰²æ˜ å°„
    const NODE_COLORS = {
      START: '#00ff00',
      BOSS: '#ff0000',
      BATTLE: '#ff6600',
      SHOP: '#00ccff',
      EVENT: '#ffff00',
      REST: '#00ff99',
      CHEST: '#ff00ff'
    };
    
    // ç”Ÿæˆåœ°å›¾
    window.generateMap = function(act) {
      const startTime = performance.now();
      
      // é‡å®šå‘console.logåˆ°é¡µé¢
      const originalLog = console.log;
      const logMessages = [];
      
      console.log = function(...args) {
        logMessages.push(args.join(' '));
        originalLog.apply(console, args);
      };
      
      try {
        currentMapData = generateGridMap(act);
        const endTime = performance.now();
        const duration = (endTime - startTime).toFixed(2);
        
        // æ¢å¤console.log
        console.log = originalLog;
        
        // æ›´æ–°ç»Ÿè®¡æ•°æ®
        updateStats(currentMapData, act, duration);
        
        // ç»˜åˆ¶åœ°å›¾
        drawMap(currentMapData);
        
        // æ›´æ–°æ—¥å¿—
        document.getElementById('logOutput').textContent = logMessages.join('\n');
        
        console.log(`âœ… Map generated successfully in ${duration}ms`);
      } catch (error) {
        console.log = originalLog;
        console.error('âŒ Map generation failed:', error);
        document.getElementById('logOutput').textContent = `ERROR: ${error.message}\n\n${error.stack}`;
      }
    };
    
    // æ›´æ–°ç»Ÿè®¡æ•°æ®
    function updateStats(mapData, act, duration) {
      document.getElementById('currentAct').textContent = `ACT ${act}`;
      document.getElementById('totalNodes').textContent = mapData.nodes.length;
      document.getElementById('minSteps').textContent = mapData.stats.minSteps;
      document.getElementById('maxSteps').textContent = mapData.stats.maxSteps;
      document.getElementById('generateTime').textContent = `${duration} ms`;
      
      const reachableEl = document.getElementById('reachable');
      reachableEl.textContent = mapData.stats.reachable ? 'âœ… æ˜¯' : 'âŒ å¦';
      reachableEl.className = mapData.stats.reachable ? 'stat-value success' : 'stat-value error';
    }
    
    // ç»˜åˆ¶åœ°å›¾
    function drawMap(mapData) {
      const canvas = document.getElementById('mapCanvas');
      const ctx = canvas.getContext('2d');
      
      // æ¸…ç©ºç”»å¸ƒ
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // è®¡ç®—ç¼©æ”¾æ¯”ä¾‹å’Œåç§»ï¼ˆä½¿åœ°å›¾å±…ä¸­ï¼‰
      const hexSize = 25; // å…­è¾¹å½¢å¤§å°
      const padding = 50;
      
      // è®¡ç®—åœ°å›¾è¾¹ç•Œ
      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      mapData.nodes.forEach(node => {
        const pos = offsetToPixel(node.row, node.col, hexSize);
        minX = Math.min(minX, pos.x);
        minY = Math.min(minY, pos.y);
        maxX = Math.max(maxX, pos.x);
        maxY = Math.max(maxY, pos.y);
      });
      
      const mapWidth = maxX - minX;
      const mapHeight = maxY - minY;
      
      // è®¡ç®—åç§»ä½¿åœ°å›¾å±…ä¸­
      const offsetX = (canvas.width - mapWidth) / 2 - minX;
      const offsetY = (canvas.height - mapHeight) / 2 - minY;
      
      // ç»˜åˆ¶è¿æ¥çº¿ï¼ˆå…ˆç»˜åˆ¶ï¼Œä½œä¸ºèƒŒæ™¯ï¼‰
      ctx.strokeStyle = 'rgba(200, 170, 110, 0.3)';
      ctx.lineWidth = 2;
      
      mapData.nodes.forEach(node => {
        const startPos = offsetToPixel(node.row, node.col, hexSize);
        const startX = startPos.x + offsetX;
        const startY = startPos.y + offsetY;
        
        node.next.forEach(nextId => {
          const nextNode = mapData.nodes.find(n => n.id === nextId);
          if (nextNode) {
            const endPos = offsetToPixel(nextNode.row, nextNode.col, hexSize);
            const endX = endPos.x + offsetX;
            const endY = endPos.y + offsetY;
            
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            ctx.lineTo(endX, endY);
            ctx.stroke();
          }
        });
      });
      
      // ç»˜åˆ¶èŠ‚ç‚¹
      mapData.nodes.forEach(node => {
        const pos = offsetToPixel(node.row, node.col, hexSize);
        const centerX = pos.x + offsetX;
        const centerY = pos.y + offsetY;
        
        // ç»˜åˆ¶å…­è¾¹å½¢
        const hexPath = new Path2D(generateHexagonPath(centerX, centerY, hexSize));
        
        // å¡«å……é¢œè‰²
        ctx.fillStyle = NODE_COLORS[node.type] || '#666666';
        ctx.fill(hexPath);
        
        // è¾¹æ¡†
        ctx.strokeStyle = '#c9aa71';
        ctx.lineWidth = 2;
        ctx.stroke(hexPath);
        
        // ç»˜åˆ¶èŠ‚ç‚¹IDï¼ˆæ–‡å­—ï¼‰
        ctx.fillStyle = '#000000';
        ctx.font = 'bold 10px Arial';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        const label = node.type === 'START' ? 'S' : node.type === 'BOSS' ? 'B' : node.row;
        ctx.fillText(label, centerX, centerY);
      });
    }
    
    // æ‰¹é‡æµ‹è¯•
    window.runBatchTest = function() {
      const iterations = 100;
      let successCount = 0;
      let failCount = 0;
      const results = { 1: [], 2: [], 3: [] };
      
      console.log(`\n=== å¼€å§‹æ‰¹é‡æµ‹è¯• (${iterations} æ¬¡) ===`);
      
      for (let i = 0; i < iterations; i++) {
        for (let act = 1; act <= 3; act++) {
          try {
            const mapData = generateGridMap(act);
            
            if (mapData.stats.reachable) {
              successCount++;
              results[act].push({
                nodes: mapData.nodes.length,
                minSteps: mapData.stats.minSteps,
                maxSteps: mapData.stats.maxSteps
              });
            } else {
              failCount++;
              console.error(`âŒ ACT${act} Iteration ${i + 1}: BOSS not reachable`);
            }
          } catch (error) {
            failCount++;
            console.error(`âŒ ACT${act} Iteration ${i + 1}: ${error.message}`);
          }
        }
      }
      
      console.log(`\n=== æµ‹è¯•å®Œæˆ ===`);
      console.log(`æˆåŠŸ: ${successCount} / ${iterations * 3}`);
      console.log(`å¤±è´¥: ${failCount} / ${iterations * 3}`);
      console.log(`æˆåŠŸç‡: ${(successCount / (iterations * 3) * 100).toFixed(2)}%`);
      
      // ç»Ÿè®¡å„ACTçš„å¹³å‡æ•°æ®
      [1, 2, 3].forEach(act => {
        const data = results[act];
        if (data.length > 0) {
          const avgNodes = (data.reduce((sum, d) => sum + d.nodes, 0) / data.length).toFixed(1);
          const avgMinSteps = (data.reduce((sum, d) => sum + d.minSteps, 0) / data.length).toFixed(1);
          const avgMaxSteps = (data.reduce((sum, d) => sum + d.maxSteps, 0) / data.length).toFixed(1);
          
          console.log(`\nACT${act} å¹³å‡æ•°æ®:`);
          console.log(`  èŠ‚ç‚¹æ•°: ${avgNodes}`);
          console.log(`  æœ€çŸ­è·¯å¾„: ${avgMinSteps}`);
          console.log(`  æœ€é•¿è·¯å¾„: ${avgMaxSteps}`);
        }
      });
      
      document.getElementById('logOutput').textContent = 'æ‰¹é‡æµ‹è¯•å®Œæˆï¼æŸ¥çœ‹æµè§ˆå™¨æ§åˆ¶å°ä»¥è·å–è¯¦ç»†ç»“æœã€‚';
    };
    
    // æ¸…ç©ºæ—¥å¿—
    window.clearLog = function() {
      document.getElementById('logOutput').textContent = 'æ—¥å¿—å·²æ¸…ç©ºã€‚';
    };
    
    // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨ç”ŸæˆACT1åœ°å›¾
    window.onload = function() {
      generateMap(1);
    };
  </script>
</body>
</html>

